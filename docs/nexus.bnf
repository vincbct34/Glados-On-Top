# ############################################################
# # Grammaire Formelle pour le Langage Ratatouille (v2.0)  #
# ############################################################

# A program is a sequence of procedure definitions and statements
<program> ::= (<proc_def> | <statement>)*

# --- Procedure Definition ---
# A procedure/function with name, parameters, optional return type, and body
<proc_def> ::= "proc" <ident> "(" <params>? ")" ("->" <type>)? "{"
                 <proc_body>
             "}"

<params> ::= "void"                                    # Empty parameter list
           | <ident> (":" <type>)? ("," <ident> (":" <type>)?)*  # Parameter list with optional types

<proc_body> ::= ("state" ":" <expr>)?           # Initial state (optional, for process-style procs)
                ("receive" "{" <case>+ "}")?    # Message handling (optional, for process-style procs)
              | <statement>* ("return" <expr>)? # Regular procedure body with statements and optional return

<case> ::= "|" <pattern> "->" <expr>

# --- Statements ---
# Actions that make up the program
<statement> ::= <let_stmt>
              | <const_stmt>
              | <assign_stmt>
              | <if_stmt>
              | <while_stmt>
              | <return_stmt>
              | <expr_stmt>

<let_stmt> ::= "let" <pattern> (":" <type>)? "=" <expr>

<const_stmt> ::= "const" <ident> ":" <type> "=" <expr>

<assign_stmt> ::= <ident> "=" <expr>

<if_stmt> ::= "if" "(" <expr> ")" "{" <statement>* "}"
              ("else" "{" <statement>* "}")?

<while_stmt> ::= "while" "(" <expr> ")" "{" <statement>* "}"

<return_stmt> ::= "return" <expr>?

<expr_stmt> ::= <expr>

# --- Expressions ---
# Everything that produces a value
<expr> ::= <logical_or_expr>

<logical_or_expr> ::= <logical_and_expr> ("||" <logical_and_expr>)*

<logical_and_expr> ::= <equality_expr> ("&&" <equality_expr>)*

<equality_expr> ::= <relational_expr> (("==" | "!=") <relational_expr>)*

<relational_expr> ::= <additive_expr> (("<" | ">" | "<=" | ">=") <additive_expr>)*

<additive_expr> ::= <multiplicative_expr> (("+" | "-" | "++") <multiplicative_expr>)*

<multiplicative_expr> ::= <cast_expr> (("*" | "/" | "%") <cast_expr>)*

<cast_expr> ::= ("scast" | "rcast" | "ccast") "<" <type> ">" "(" <expr> ")"
              | <unary_expr>

<unary_expr> ::= "!" <unary_expr>
               | "-" <unary_expr>
               | <postfix_expr>

<postfix_expr> ::= <primary_expr> ("[" <expr> "]")*  # Array indexing

<primary_expr> ::= <ident>                           # Variable reference
                 | <literal>                         # Literal value
                 | <atom>                            # Atom/symbol
                 | <tuple_expr>                      # Tuple literal
                 | <array_expr>                      # Array literal
                 | <call_expr>                       # Function call
                 | <spawn_expr>                      # Process spawn
                 | <send_expr>                       # Message send
                 | <receive_expr>                    # Message receive
                 | <if_expr>                         # If expression
                 | <match_expr>                      # Pattern matching
                 | "self"                            # Current process PID
                 | "(" <expr> ")"                    # Parenthesized expression

# --- Specific Constructs ---

<tuple_expr> ::= "(" <expr> ("," <expr>)+ ")"        # Tuple with 2+ elements
               | "()"                                 # Unit/empty tuple

<array_expr> ::= "[" (<expr> ("," <expr>)*)? "]"     # Array literal

<call_expr> ::= <ident> "(" (<expr> ("," <expr>)*)? ")"

<spawn_expr> ::= "spawn" <ident> "(" (<expr> ("," <expr>)*)? ")"

<send_expr> ::= <expr> "<-" <expr>

<receive_expr> ::= "receive" "{" <case>+ "}"

<if_expr> ::= "if" "(" <expr> ")" <expr> ("else" <expr>)?

<match_expr> ::= "match" <expr> "{" <match_case> ("," <match_case>)* "}"

<match_case> ::= <pattern> "=>" <expr>

# --- Patterns (for destructuring and pattern matching) ---
<pattern> ::= <ident>                                 # Variable binding
            | "_"                                      # Wildcard, ignores value
            | <literal>                                # Literal pattern match
            | <atom>                                   # Atom pattern match
            | "(" <pattern> ("," <pattern>)+ ")"       # Tuple pattern
            | "[" <pattern> ("," <pattern>)* "]"       # Array pattern
            | <ident> ":" <type>                       # Typed pattern
            | "const" <ident> (":" <type>)?            # Const pattern

# --- Types ---
<type> ::= <numeric_type>
         | "bool"
         | "string"
         | "atom"
         | "void"
         | "unit"
         | "pid"
         | "none"
         | "(" <type> ("," <type>)+ ")"                # Tuple type
         | "[" <type> "]"                              # Array type

<numeric_type> ::= "i8" | "i16" | "i32" | "i64"       # Signed integers
                 | "u8" | "u16" | "u32" | "u64"       # Unsigned integers
                 | "f32" | "f64"                      # Floating point

# --- Literals ---
<literal> ::= <integer_literal>
            | <float_literal>
            | <bool_literal>
            | <string_literal>
            | "none"

<integer_literal> ::= <integer> (<numeric_type_suffix>)?

<float_literal> ::= <float> (<float_type_suffix>)?

<bool_literal> ::= "true" | "false"

<string_literal> ::= <string>

# --- Terminal Elements (Lexer) ---
<ident>   ::= /[a-zA-Z_][a-zA-Z0-9_]*/               # Identifier: my_var, counter
<atom>    ::= /:[a-zA-Z_][a-zA-Z0-9_]*/              # Atom: :ok, :error, :increment
<integer> ::= /-?\d+/                                # Integer: 42, -17, 0
<float>   ::= /-?\d+\.\d+/                           # Float: 3.14, -0.5, 2.718
<string>  ::= /"([^"\\]|\\.)*"/                      # String: "hello", "world"

<numeric_type_suffix> ::= "i8" | "i16" | "i32" | "i64"
                        | "u8" | "u16" | "u32" | "u64"

<float_type_suffix> ::= "f32" | "f64"

# --- Keywords ---
# Reserved words that cannot be used as identifiers:
# proc, receive, spawn, let, const, if, then, else, while, match, return
# self, none, void, true, false, scast, rcast, ccast, state

# --- Operators ---
# Arithmetic: +, -, *, /, %
# Comparison: ==, !=, <, >, <=, >=
# Logical: &&, ||, !
# String: ++
# Assignment: =
# Message: <-
# Array: []
# Type: :

# --- Comments ---
# Single-line comments start with '#'
<comment> ::= /#[^\n]*/

# --- Examples ---

# Example 1: Simple procedure
# proc add(a: i32, b: i32) -> i32 {
#     return a + b;
# }

# Example 2: Procedure with void return
# proc greet(name: string) -> void {
#     print("Hello, " ++ name);
# }

# Example 3: Constants and variables
# const PI: f32 = 3.14159f32;
# let radius: f32 = 5.0f32;
# let area = PI * radius * radius;

# Example 4: Tuples and destructuring
# let point: (i32, i32) = (10, 20);
# let (x, y) = point;

# Example 5: Arrays
# let numbers: [i32] = [1, 2, 3, 4, 5];
# let first = numbers[0];

# Example 6: Pattern matching
# match point {
#     (0, 0) => print("Origin"),
#     (x, 0) => print("X-axis"),
#     (0, y) => print("Y-axis"),
#     (x, y) => print("Point")
# }

# Example 7: Process definition
# proc Counter() {
#     state: 0,
#     receive {
#         | :increment -> state + 1
#         | :get -> state
#     }
# }

# Example 8: Spawning and messaging
# let counter = spawn Counter();
# counter <- :increment;
# counter <- :get;

# Example 9: Boolean operations
# let is_valid: bool = true;
# if (is_valid && x > 0) {
#     print("Valid");
# } else {
#     print("Invalid");
# }

# Example 10: Type casting
# let x: i32 = 42;
# let y: f32 = scast<f32>(x);
